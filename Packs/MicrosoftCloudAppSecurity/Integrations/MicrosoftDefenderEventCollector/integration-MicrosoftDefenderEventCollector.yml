category: Analytics & SIEM
commonfields:
  id: Microsoft Defender for Cloud Apps Event Collector
  version: -1
configuration:
- additionalinfo: |-
    The United States: api-us.security.microsoft.com
    Europe: api-eu.security.microsoft.com
    The United Kingdom: api-uk.security.microsoft.com
  display: Endpoint URI
  hidden: false
  name: url
  required: true
  type: 0
- additionalinfo: The Client (Application) ID to use to connect.
  display: Client (Application) ID
  name: client_id
  required: true
  type: 0
- displaypassword: Client Secret
  name: credentials
  required: true
  type: 9
  hiddenusername: true
- display: Tenant ID
  name: tenant_id
  required: true
  type: 0
- display: Scope
  name: scope
  required: true
  type: 0
- defaultvalue: 3 days
  display: First fetch timestamp (<number> <time unit>, e.g., 12 hours, 7 days)
  hidden: false
  name: after
  required: false
  type: 0
- defaultvalue: Microsoft
  additionalinfo: The vendor name to be used in the dataset name, in this format <vendor>_<product>_raw.
  display: Vendor
  hidden: false
  name: vendor
  required: false
  type: 0
- defaultvalue: defender_cloud_apps
  display: Product
  hidden: false
  name: product
  required: false
  type: 0
- additionalinfo: Due to API limitations, the maximum is 10,000.
  defaultvalue: '10000'
  display: Number of alerts for each fetch.
  hidden: false
  name: limit
  required: false
  type: 0
- display: Fetch events
  name: isFetchEvents
  required: false
  type: 8
- display: Verify SSL Certificate
  hidden: false
  name: verify
  required: false
  defaultvalue: 'true'
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
description: Microsoft Defender for Cloud Apps Event Collector integration.
display: Microsoft Defender for Cloud Apps Event Collector
name: Microsoft Defender for Cloud Apps Event Collector
script:
  commands:
  - deprecated: false
    description: Returns a list of alerts.
    execution: false
    name: microsoft-defender-cloud-apps-get-events
    arguments:
    - description: The maximum number of alerts per fetch.
      defaultValue: '10000'
      isArray: true
      name: limit
      required: false
      secret: false
    - description: The first fetch time (<number> <time unit>, for example 12 hours, 1 day, 3 months).
      defaultValue: 3 days
      isArray: true
      name: after
      required: false
      secret: false
    - auto: PREDEFINED
      default: true
      defaultValue: 'false'
      description: Whether to push the fetched event to XSIAM or not.
      isArray: false
      name: push_to_xsiam
      predefined:
      - 'false'
      - 'true'
      required: false
      secret: false
  isfetch: false
  isfetchevents: true
  runonce: false
  script: >
    register_module_line('Microsoft Defender for Cloud Apps Event Collector', 'start', __line__())


    # pylint: disable=no-name-in-module

    # pylint: disable=no-self-argument






    from abc import ABC

    from typing import Any, Callable, Optional


    from enum import Enum

    from pydantic import BaseConfig, BaseModel, AnyUrl, validator  # type: ignore[E0611, E0611, E0611]

    from requests.auth import HTTPBasicAuth

    import requests

    import dateparser



    ### GENERATED CODE ###: from MicrosoftApiModule import *

    # This code was inserted in place of an API module.

    register_module_line('MicrosoftApiModule', 'start', __line__(), wrapper=-3)

    import traceback





    import requests

    import re

    import base64

    from cryptography.hazmat.primitives.ciphers.aead import AESGCM

    from typing import Dict, Tuple, List, Optional



    class Scopes:
        graph = 'https://graph.microsoft.com/.default'
        security_center = 'https://api.securitycenter.windows.com/.default'
        security_center_apt_service = 'https://securitycenter.onmicrosoft.com/windowsatpservice/.default'
        management_azure = 'https://management.azure.com/.default'


    # authorization types

    OPROXY_AUTH_TYPE = 'oproxy'

    SELF_DEPLOYED_AUTH_TYPE = 'self_deployed'


    # grant types in self-deployed authorization

    CLIENT_CREDENTIALS = 'client_credentials'

    AUTHORIZATION_CODE = 'authorization_code'

    REFRESH_TOKEN = 'refresh_token'  # guardrails-disable-line

    DEVICE_CODE = 'urn:ietf:params:oauth:grant-type:device_code'

    REGEX_SEARCH_URL = r'(?P<url>https?://[^\s]+)'

    SESSION_STATE = 'session_state'

    TOKEN_RETRIEVAL_ENDPOINTS = {
        'com': 'https://login.microsoftonline.com',
        'gcc-high': 'https://login.microsoftonline.us',
        'dod': 'https://login.microsoftonline.us',
        'de': 'https://login.microsoftonline.de',
        'cn': 'https://login.chinacloudapi.cn',
    }

    GRAPH_ENDPOINTS = {
        'com': 'https://graph.microsoft.com',
        'gcc-high': 'https://graph.microsoft.us',
        'dod': 'https://dod-graph.microsoft.us',
        'de': 'https://graph.microsoft.de',
        'cn': 'https://microsoftgraph.chinacloudapi.cn'
    }

    GRAPH_BASE_ENDPOINTS = {
        'https://graph.microsoft.com': 'com',
        'https://graph.microsoft.us': 'gcc-high',
        'https://dod-graph.microsoft.us': 'dod',
        'https://graph.microsoft.de': 'de',
        'https://microsoftgraph.chinacloudapi.cn': 'cn'
    }



    class MicrosoftClient(BaseClient):
        def __init__(self, tenant_id: str = '',
                     auth_id: str = '',
                     enc_key: Optional[str] = '',
                     token_retrieval_url: str = '{endpoint}/{tenant_id}/oauth2/v2.0/token',
                     app_name: str = '',
                     refresh_token: str = '',
                     auth_code: str = '',
                     scope: str = '{graph_endpoint}/.default',
                     grant_type: str = CLIENT_CREDENTIALS,
                     redirect_uri: str = 'https://localhost/myapp',
                     resource: Optional[str] = '',
                     multi_resource: bool = False,
                     resources: List[str] = None,
                     verify: bool = True,
                     self_deployed: bool = False,
                     timeout: Optional[int] = None,
                     azure_ad_endpoint: str = '{endpoint}',
                     endpoint: str = 'com',
                     certificate_thumbprint: Optional[str] = None,
                     private_key: Optional[str] = None,
                     *args, **kwargs):
            """
            Microsoft Client class that implements logic to authenticate with oproxy or self deployed applications.
            It also provides common logic to handle responses from Microsoft.
            Args:
                tenant_id: If self deployed it's the tenant for the app url, otherwise (oproxy) it's the token
                auth_id: If self deployed it's the client id, otherwise (oproxy) it's the auth id and may also
                contain the token url
                enc_key: If self deployed it's the client secret, otherwise (oproxy) it's the encryption key
                scope: The scope of the application (only if self deployed)
                resource: The resource of the application (only if self deployed)
                multi_resource: Where or not module uses a multiple resources (self-deployed, auth_code grant type only)
                resources: Resources of the application (for multi-resource mode)
                verify: Demisto insecure parameter
                self_deployed: Indicates whether the integration mode is self deployed or oproxy
                certificate_thumbprint: Certificate's thumbprint that's associated to the app
                private_key: Private key of the certificate
            """
            super().__init__(verify=verify, *args, **kwargs)  # type: ignore[misc]
            self.endpoint = endpoint
            if not self_deployed:
                auth_id_and_token_retrieval_url = auth_id.split('@')
                auth_id = auth_id_and_token_retrieval_url[0]
                if len(auth_id_and_token_retrieval_url) != 2:
                    self.token_retrieval_url = 'https://oproxy.demisto.ninja/obtain-token'  # guardrails-disable-line
                else:
                    self.token_retrieval_url = auth_id_and_token_retrieval_url[1]

                self.app_name = app_name
                self.auth_id = auth_id
                self.enc_key = enc_key
                self.tenant_id = tenant_id
                self.refresh_token = refresh_token

            else:
                self.token_retrieval_url = token_retrieval_url.format(tenant_id=tenant_id,
                                                                      endpoint=TOKEN_RETRIEVAL_ENDPOINTS[self.endpoint])
                self.client_id = auth_id
                self.client_secret = enc_key
                self.tenant_id = tenant_id
                self.auth_code = auth_code
                self.grant_type = grant_type
                self.resource = resource
                self.scope = scope.format(graph_endpoint=GRAPH_ENDPOINTS[self.endpoint])
                self.redirect_uri = redirect_uri
                if certificate_thumbprint and private_key:
                    try:
                        import msal  # pylint: disable=E0401
                        self.jwt = msal.oauth2cli.assertion.JwtAssertionCreator(
                            private_key,
                            'RS256',
                            certificate_thumbprint
                        ).create_normal_assertion(audience=self.token_retrieval_url, issuer=self.client_id)
                    except ModuleNotFoundError:
                        raise DemistoException('Unable to use certificate authentication because `msal` is missing.')
                else:
                    self.jwt = None

            self.auth_type = SELF_DEPLOYED_AUTH_TYPE if self_deployed else OPROXY_AUTH_TYPE
            self.verify = verify
            self.azure_ad_endpoint = azure_ad_endpoint.format(endpoint=TOKEN_RETRIEVAL_ENDPOINTS[self.endpoint])
            self.timeout = timeout  # type: ignore

            self.multi_resource = multi_resource
            if self.multi_resource:
                self.resources = resources if resources else []
                self.resource_to_access_token: Dict[str, str] = {}

        def http_request(
                self, *args, resp_type='json', headers=None,
                return_empty_response=False, scope: Optional[str] = None,
                resource: str = '', **kwargs):
            """
            Overrides Base client request function, retrieves and adds to headers access token before sending the request.

            Args:
                resp_type: Type of response to return. will be ignored if `return_empty_response` is True.
                headers: Headers to add to the request.
                return_empty_response: Return the response itself if the return_code is 206.
                scope: A scope to request. Currently will work only with self-deployed app.
                resource (str): The resource identifier for which the generated token will have access to.
            Returns:
                Response from api according to resp_type. The default is `json` (dict or list).
            """
            if 'ok_codes' not in kwargs and not self._ok_codes:
                kwargs['ok_codes'] = (200, 201, 202, 204, 206, 404)
            token = self.get_access_token(resource=resource, scope=scope)
            default_headers = {
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }

            if headers:
                default_headers.update(headers)

            if self.timeout:
                kwargs['timeout'] = self.timeout

            response = super()._http_request(  # type: ignore[misc]
                *args, resp_type="response", headers=default_headers, **kwargs)

            # 206 indicates Partial Content, reason will be in the warning header.
            # In that case, logs with the warning header will be written.
            if response.status_code == 206:
                demisto.debug(str(response.headers))
            is_response_empty_and_successful = (response.status_code == 204)
            if is_response_empty_and_successful and return_empty_response:
                return response

            # Handle 404 errors instead of raising them as exceptions:
            if response.status_code == 404:
                try:
                    error_message = response.json()
                except Exception:
                    error_message = 'Not Found - 404 Response'
                raise NotFoundError(error_message)

            try:
                if resp_type == 'json':
                    return response.json()
                if resp_type == 'text':
                    return response.text
                if resp_type == 'content':
                    return response.content
                if resp_type == 'xml':
                    ET.parse(response.text)
                return response
            except ValueError as exception:
                raise DemistoException('Failed to parse json object from response: {}'.format(response.content), exception)

        def get_access_token(self, resource: str = '', scope: Optional[str] = None) -> str:
            """
            Obtains access and refresh token from oproxy server or just a token from a self deployed app.
            Access token is used and stored in the integration context
            until expiration time. After expiration, new refresh token and access token are obtained and stored in the
            integration context.

            Args:
                resource (str): The resource identifier for which the generated token will have access to.
                scope (str): A scope to get instead of the default on the API.

            Returns:
                str: Access token that will be added to authorization header.
            """
            integration_context = get_integration_context()
            refresh_token = integration_context.get('current_refresh_token', '')
            # Set keywords. Default without the scope prefix.
            access_token_keyword = f'{scope}_access_token' if scope else 'access_token'
            valid_until_keyword = f'{scope}_valid_until' if scope else 'valid_until'

            if self.multi_resource:
                access_token = integration_context.get(resource)
            else:
                access_token = integration_context.get(access_token_keyword)

            valid_until = integration_context.get(valid_until_keyword)

            if access_token and valid_until:
                if self.epoch_seconds() < valid_until:
                    return access_token

            if self.auth_type == OPROXY_AUTH_TYPE:
                if self.multi_resource:
                    for resource_str in self.resources:
                        access_token, expires_in, refresh_token = self._oproxy_authorize(resource_str)
                        self.resource_to_access_token[resource_str] = access_token
                        self.refresh_token = refresh_token
                else:
                    access_token, expires_in, refresh_token = self._oproxy_authorize(scope=scope)

            else:
                access_token, expires_in, refresh_token = self._get_self_deployed_token(
                    refresh_token, scope, integration_context)
            time_now = self.epoch_seconds()
            time_buffer = 5  # seconds by which to shorten the validity period
            if expires_in - time_buffer > 0:
                # err on the side of caution with a slightly shorter access token validity period
                expires_in = expires_in - time_buffer
            valid_until = time_now + expires_in
            integration_context.update({
                access_token_keyword: access_token,
                valid_until_keyword: valid_until,
                'current_refresh_token': refresh_token
            })

            # Add resource access token mapping
            if self.multi_resource:
                integration_context.update(self.resource_to_access_token)

            set_integration_context(integration_context)

            if self.multi_resource:
                return self.resource_to_access_token[resource]

            return access_token

        def _oproxy_authorize(self, resource: str = '', scope: Optional[str] = None) -> Tuple[str, int, str]:
            """
            Gets a token by authorizing with oproxy.
            Args:
                scope: A scope to add to the request. Do not use it.
                resource: Resource to get.
            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            content = self.refresh_token or self.tenant_id
            headers = self._add_info_headers()
            oproxy_response = requests.post(
                self.token_retrieval_url,
                headers=headers,
                json={
                    'app_name': self.app_name,
                    'registration_id': self.auth_id,
                    'encrypted_token': self.get_encrypted(content, self.enc_key),
                    'scope': scope,
                    'resource': resource
                },
                verify=self.verify
            )

            if not oproxy_response.ok:
                msg = 'Error in authentication. Try checking the credentials you entered.'
                try:
                    demisto.info('Authentication failure from server: {} {} {}'.format(
                        oproxy_response.status_code, oproxy_response.reason, oproxy_response.text))
                    err_response = oproxy_response.json()
                    server_msg = err_response.get('message')
                    if not server_msg:
                        title = err_response.get('title')
                        detail = err_response.get('detail')
                        if title:
                            server_msg = f'{title}. {detail}'
                        elif detail:
                            server_msg = detail
                    if server_msg:
                        msg += ' Server message: {}'.format(server_msg)
                except Exception as ex:
                    demisto.error('Failed parsing error response - Exception: {}'.format(ex))
                raise Exception(msg)
            try:
                gcloud_function_exec_id = oproxy_response.headers.get('Function-Execution-Id')
                demisto.info(f'Google Cloud Function Execution ID: {gcloud_function_exec_id}')
                parsed_response = oproxy_response.json()
            except ValueError:
                raise Exception(
                    'There was a problem in retrieving an updated access token.\n'
                    'The response from the Oproxy server did not contain the expected content.'
                )

            return (parsed_response.get('access_token', ''), parsed_response.get('expires_in', 3595),
                    parsed_response.get('refresh_token', ''))

        def _get_self_deployed_token(self,
                                     refresh_token: str = '',
                                     scope: Optional[str] = None,
                                     integration_context: Optional[dict] = None
                                     ) -> Tuple[str, int, str]:
            if self.grant_type == AUTHORIZATION_CODE:
                if not self.multi_resource:
                    return self._get_self_deployed_token_auth_code(refresh_token, scope=scope)
                else:
                    expires_in = -1  # init variable as an int
                    for resource in self.resources:
                        access_token, expires_in, refresh_token = self._get_self_deployed_token_auth_code(refresh_token,
                                                                                                          resource)
                        self.resource_to_access_token[resource] = access_token

                    return '', expires_in, refresh_token
            elif self.grant_type == DEVICE_CODE:
                return self._get_token_device_code(refresh_token, scope, integration_context)
            else:
                # by default, grant_type is CLIENT_CREDENTIALS
                if self.multi_resource:
                    expires_in = -1  # init variable as an int
                    for resource in self.resources:
                        access_token, expires_in, refresh_token = self._get_self_deployed_token_client_credentials(
                            resource=resource)
                        self.resource_to_access_token[resource] = access_token
                    return '', expires_in, refresh_token
                return self._get_self_deployed_token_client_credentials(scope=scope)

        def _get_self_deployed_token_client_credentials(self, scope: Optional[str] = None,
                                                        resource: Optional[str] = None) -> Tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application in client credentials grant type.

            Args:
                scope: A scope to add to the headers. Else will get self.scope.
                resource: A resource to add to the headers. Else will get self.resource.
            Returns:
                tuple: An access token and its expiry.
            """
            data = {
                'client_id': self.client_id,
                'client_secret': self.client_secret,
                'grant_type': CLIENT_CREDENTIALS
            }

            if self.jwt:
                data.pop('client_secret', None)
                data['client_assertion_type'] = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
                data['client_assertion'] = self.jwt

            # Set scope.
            if self.scope or scope:
                data['scope'] = scope if scope else self.scope

            if self.resource or resource:
                data['resource'] = resource or self.resource  # type: ignore

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))

            return access_token, expires_in, ''

        def _get_self_deployed_token_auth_code(
                self, refresh_token: str = '', resource: str = '', scope: Optional[str] = None) -> Tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application.
            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            data = assign_params(
                client_id=self.client_id,
                client_secret=self.client_secret,
                resource=self.resource if not resource else resource,
                redirect_uri=self.redirect_uri
            )

            if self.jwt:
                data.pop('client_secret', None)
                data['client_assertion_type'] = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
                data['client_assertion'] = self.jwt

            if scope:
                data['scope'] = scope

            refresh_token = refresh_token or self._get_refresh_token_from_auth_code_param()
            if refresh_token:
                data['grant_type'] = REFRESH_TOKEN
                data['refresh_token'] = refresh_token
            else:
                if SESSION_STATE in self.auth_code:
                    raise ValueError('Malformed auth_code parameter: Please copy the auth code from the redirected uri '
                                     'without any additional info and without the "session_state" query parameter.')
                data['grant_type'] = AUTHORIZATION_CODE
                data['code'] = self.auth_code

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))
            refresh_token = response_json.get('refresh_token', '')

            return access_token, expires_in, refresh_token

        def _get_token_device_code(
                self, refresh_token: str = '', scope: Optional[str] = None, integration_context: Optional[dict] = None
        ) -> Tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application.

            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            data = {
                'client_id': self.client_id,
                'scope': scope
            }

            if refresh_token:
                data['grant_type'] = REFRESH_TOKEN
                data['refresh_token'] = refresh_token
            else:
                data['grant_type'] = DEVICE_CODE
                if integration_context:
                    data['code'] = integration_context.get('device_code')

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))
            refresh_token = response_json.get('refresh_token', '')

            return access_token, expires_in, refresh_token

        def _get_refresh_token_from_auth_code_param(self) -> str:
            refresh_prefix = "refresh_token:"
            if self.auth_code.startswith(refresh_prefix):  # for testing we allow setting the refresh token directly
                demisto.debug("Using refresh token set as auth_code")
                return self.auth_code[len(refresh_prefix):]
            return ''

        @staticmethod
        def error_parser(error: requests.Response) -> str:
            """

            Args:
                error (requests.Response): response with error

            Returns:
                str: string of error

            """
            try:
                response = error.json()
                demisto.error(str(response))
                inner_error = response.get('error', {})
                if isinstance(inner_error, dict):
                    err_str = f"{inner_error.get('code')}: {inner_error.get('message')}"
                else:
                    err_str = inner_error
                if err_str:
                    return err_str
                # If no error message
                raise ValueError
            except ValueError:
                return error.text

        @staticmethod
        def epoch_seconds(d: datetime = None) -> int:
            """
            Return the number of seconds for given date. If no date, return current.

            Args:
                d (datetime): timestamp
            Returns:
                 int: timestamp in epoch
            """
            if not d:
                d = MicrosoftClient._get_utcnow()
            return int((d - MicrosoftClient._get_utcfromtimestamp(0)).total_seconds())

        @staticmethod
        def _get_utcnow() -> datetime:
            return datetime.utcnow()

        @staticmethod
        def _get_utcfromtimestamp(_time) -> datetime:
            return datetime.utcfromtimestamp(_time)

        @staticmethod
        def get_encrypted(content: str, key: Optional[str]) -> str:
            """
            Encrypts content with encryption key.
            Args:
                content: Content to encrypt
                key: encryption key from oproxy

            Returns:
                timestamp: Encrypted content
            """

            def create_nonce():
                return os.urandom(12)

            def encrypt(string, enc_key):
                """
                Encrypts string input with encryption key.
                Args:
                    string: String to encrypt
                    enc_key: Encryption key

                Returns:
                    bytes: Encrypted value
                """
                # String to bytes
                try:
                    enc_key = base64.b64decode(enc_key)
                except Exception as err:
                    return_error(f"Error in Microsoft authorization: {str(err)}"
                                 f" Please check authentication related parameters.", error=traceback.format_exc())

                # Create key
                aes_gcm = AESGCM(enc_key)
                # Create nonce
                nonce = create_nonce()
                # Create ciphered data
                data = string.encode()
                ct = aes_gcm.encrypt(nonce, data, None)
                return base64.b64encode(nonce + ct)

            now = MicrosoftClient.epoch_seconds()
            encrypted = encrypt(f'{now}:{content}', key).decode('utf-8')
            return encrypted

        @staticmethod
        def _add_info_headers() -> Dict[str, str]:
            # pylint: disable=no-member
            headers = {}
            try:
                headers = get_x_content_info_headers()
            except Exception as e:
                demisto.error('Failed getting integration info: {}'.format(str(e)))

            return headers

        def device_auth_request(self) -> dict:
            response_json = {}
            try:
                response = requests.post(
                    url=f'{self.azure_ad_endpoint}/organizations/oauth2/v2.0/devicecode',
                    data={
                        'client_id': self.client_id,
                        'scope': self.scope
                    },
                    verify=self.verify
                )
                if not response.ok:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')
            set_integration_context({'device_code': response_json.get('device_code')})
            return response_json

        def start_auth(self, complete_command: str) -> str:
            response = self.device_auth_request()
            message = response.get('message', '')
            re_search = re.search(REGEX_SEARCH_URL, message)
            url = re_search.group('url') if re_search else None
            user_code = response.get('user_code')

            return f"""### Authorization instructions
    1. To sign in, use a web browser to open the page [{url}]({url})

    and enter the code **{user_code}** to authenticate.

    2. Run the **{complete_command}** command in the War Room."""



    class NotFoundError(Exception):
        """Exception raised for 404 - Not Found errors.

        Attributes:
            message -- explanation of the error
        """

        def __init__(self, message):
            self.message = message

    register_module_line('MicrosoftApiModule', 'end', __line__(), wrapper=1)

    ### END GENERATED CODE ###

    # Disable insecure warnings

    requests.packages.urllib3.disable_warnings()  # pylint: disable=no-member



    ''' CONSTANTS '''

    AUTH_ERROR_MSG = 'Authorization Error: make sure tenant id, client id and client secret is correctly set'

    TYPES_TO_RETRIEVE = ['alerts', 'activities']


    ''' HELPER CLASSES '''


    # COPY OF SiemApiModule



    class Method(str, Enum):
        GET = 'GET'
        POST = 'POST'
        PUT = 'PUT'
        HEAD = 'HEAD'
        PATCH = 'PATCH'
        DELETE = 'DELETE'


    def load_json(v: Any) -> dict:
        if not isinstance(v, (dict, str)):
            raise ValueError('headers are not dict or a valid json')
        if isinstance(v, str):
            try:
                v = json.loads(v)
                if not isinstance(v, dict):
                    raise ValueError('headers are not from dict type')
            except json.decoder.JSONDecodeError as exc:
                raise ValueError('headers are not valid Json object') from exc
        if isinstance(v, dict):
            return v


    class IntegrationHTTPRequest(BaseModel):
        method: Method
        url: AnyUrl
        verify: bool = True
        headers: dict = dict()  # type: ignore[type-arg]
        auth: Optional[HTTPBasicAuth]
        data: Any = None

        class Config(BaseConfig):
            arbitrary_types_allowed = True

        _normalize_headers = validator('headers', pre=True, allow_reuse=True)(
            load_json
        )


    class Credentials(BaseModel):
        identifier: Optional[str]
        password: str


    def set_authorization(request: IntegrationHTTPRequest, auth_credentials):
        """Automatic authorization.
        Supports {Authorization: Bearer __token__}
        or Basic Auth.
        """
        creds = Credentials.parse_obj(auth_credentials)
        if creds.password and creds.identifier:
            request.auth = HTTPBasicAuth(creds.identifier, creds.password)
        auth = {'Authorization': f'Bearer {creds.password}'}
        if request.headers:
            request.headers |= auth  # type: ignore[assignment, operator]
        else:
            request.headers = auth  # type: ignore[assignment]


    class IntegrationOptions(BaseModel):
        """Add here any option you need to add to the logic"""

        proxy: bool = False
        limit: int = 1000


    class IntegrationEventsClient(ABC):
        def __init__(
            self,
            request: IntegrationHTTPRequest,
            options: IntegrationOptions,
            session=requests.Session(),
        ):
            self.request = request
            self.options = options
            self.session = session
            self._set_proxy()
            self._skip_cert_verification()

        @abstractmethod
        def set_request_filter(self, after: Any):
            """TODO: set the next request's filter.
            Example:
            """
            self.request.headers['after'] = after

        def __del__(self):
            try:
                self.session.close()
            except AttributeError as err:
                demisto.debug(
                    f'ignore exceptions raised due to session not used by the client. {err=}'
                )

        def call(self, request: IntegrationHTTPRequest) -> requests.Response:
            try:
                response = self.session.request(**request.dict())
                response.raise_for_status()
                return response
            except Exception as exc:
                msg = f'something went wrong with the http call {exc}'
                LOG(msg)
                raise DemistoException(msg) from exc

        def _skip_cert_verification(
            self, skip_cert_verification: Callable = skip_cert_verification
        ):
            if not self.request.verify:
                skip_cert_verification()

        def _set_proxy(self):
            if self.options.proxy:
                ensure_proxy_has_http_prefix()
            else:
                skip_proxy()


    class IntegrationGetEvents(ABC):
        def __init__(
            self, client: IntegrationEventsClient, options: IntegrationOptions
        ) -> None:
            self.client = client
            self.options = options

        def run(self):
            stored = []
            for logs in self._iter_events():
                stored.extend(logs)
                if len(stored) >= self.options.limit:
                    return stored[:self.options.limit]
            return stored

        def call(self) -> requests.Response:
            return self.client.call(self.client.request)

        @staticmethod
        @abstractmethod
        def get_last_run(events: list) -> dict:
            """Logic to get the last run from the events
            Example:
            """
            return {'after': events[-1]['created']}

        @abstractmethod
        def _iter_events(self):
            """Create iterators with Yield"""
            pass

    # END COPY OF SiemApiModule



    class DefenderAuthenticator(BaseModel):
        verify: bool
        url: str
        tenant_id: str
        client_id: str
        client_secret: str
        scope: str
        ms_client: Any = None

        def set_authorization(self, request: IntegrationHTTPRequest):
            try:
                if not self.ms_client:
                    demisto.debug('try init the ms client for the first time')
                    self.ms_client = MicrosoftClient(
                        base_url=self.url,
                        tenant_id=self.tenant_id,
                        auth_id=self.client_id,
                        enc_key=self.client_secret,
                        scope=self.scope,
                        verify=self.verify,
                        self_deployed=True
                    )

                token = self.ms_client.get_access_token()
                auth = {'Authorization': f'Bearer {token}'}
                if request.headers:
                    request.headers |= auth  # type: ignore[assignment, operator]
                else:
                    request.headers = auth  # type: ignore[assignment]

                demisto.debug('getting access token for Defender Authenticator - succeeded')

            except BaseException as e:
                # catch BaseException to catch also sys.exit via return_error
                demisto.error(f'Fail to authenticate with Microsoft services: {str(e)}')

                err_msg = 'Fail to authenticate with Microsoft services, see the error details in the log'
                raise DemistoException(err_msg)


    class DefenderHTTPRequest(IntegrationHTTPRequest):
        params: dict = {'sortDirection': 'asc'}
        method: Method = Method.GET

        _normalize_url = validator('url', pre=True, allow_reuse=True)(
            lambda base_url: base_url + '/api/v1/'
        )


    class DefenderClient(IntegrationEventsClient):

        authenticator: DefenderAuthenticator
        request: DefenderHTTPRequest
        options: IntegrationOptions

        def __init__(self, request: DefenderHTTPRequest, options: IntegrationOptions, authenticator: DefenderAuthenticator,
                     after: int):
            self.after = after
            self.authenticator = authenticator
            super().__init__(request, options)

        def set_request_filter(self, after: Any):
            self.request.params['filters'] = json.dumps({"date": {"gte": after+1}})

        def authenticate(self):
            self.authenticator.set_authorization(self.request)


    class DefenderGetEvents(IntegrationGetEvents):
        client: DefenderClient

        def _iter_events(self):
            self.last_timestamp = {}
            base_url = self.client.request.url
            self.client.authenticate()

            for type_ in TYPES_TO_RETRIEVE:
                self.client.request.params.pop('filters', None)
                self.client.request.url = f'{base_url}{type_}'

                after = demisto.getLastRun().get(type_) or self.client.after

                if after:
                    self.client.request.params['filters'] = json.dumps({"date": {"gte": after}})
                response = self.client.call(self.client.request).json()
                events = response.get('data', [])
                has_next = response.get('hasNext')

                yield events

                while has_next:
                    last = events.pop()
                    self.client.set_request_filter(last['timestamp'])
                    response = self.client.call(self.client.request).json()
                    events = response.get('data', [])
                    has_next = response.get('hasNext')

                    yield events

        @staticmethod
        def get_last_run(events: list) -> dict:
            last_run = demisto.getLastRun()
            alerts_last_run = 0
            activities_last_run = 0

            for event in events:
                timestamp = event['timestamp']
                if event.get('isSystemAlert') is not None:
                    alerts_last_run = timestamp
                else:
                    activities_last_run = timestamp

            if alerts_last_run:
                last_run['alerts'] = alerts_last_run + 1
            if activities_last_run:
                last_run['activities'] = activities_last_run + 1

            return last_run


    ''' HELPER FUNCTIONS '''



    ''' COMMAND FUNCTIONS '''



    def test_module(get_events: DefenderGetEvents) -> str:
        """Tests API connectivity and authentication'

        Returning 'ok' indicates that the integration works like it is supposed to.
        Connection to the service is successful.
        Raises exceptions if something goes wrong.

        :type get_events: ``DefenderGetEvents``
        :param get_events: the get_events instance

        :return: 'ok' if test passed, anything else will fail the test.
        :rtype: ``str``
        """

        try:
            get_events.client.request.params = {'limit': 1}
            get_events.run()
            message = 'ok'
        except DemistoException as e:
            if 'Forbidden' in str(e) or 'authenticate' in str(e):
                message = AUTH_ERROR_MSG
            else:
                raise
        return message


    def main(command: str, demisto_params: dict):

        demisto.debug(f'Command being called is {command}')

        try:
            demisto_params['client_secret'] = demisto_params['credentials']['password']
            push_to_xsiam = argToBoolean(demisto_params.get('push_to_xsiam', 'false'))
            vendor = demisto_params.get('vendor')
            product = demisto_params.get('product')

            after = demisto_params.get('after')
            if after and not isinstance(after, int):
                timestamp = dateparser.parse(after)
                after = int(timestamp.timestamp() * 1000)

            options = IntegrationOptions.parse_obj(demisto_params)
            request = DefenderHTTPRequest.parse_obj(demisto_params)
            authenticator = DefenderAuthenticator.parse_obj(demisto_params)

            client = DefenderClient(request=request, options=options, authenticator=authenticator,
                                    after=after)
            get_events = DefenderGetEvents(client=client, options=options)

            if command == 'test-module':
                return_results(test_module(get_events=get_events))

            elif command in ('fetch-events', 'microsoft-defender-cloud-apps-get-events'):
                events = get_events.run()

                if command == 'fetch-events':
                    # publishing events to XSIAM
                    send_events_to_xsiam(events, vendor=vendor, product=product)
                    demisto.setLastRun(DefenderGetEvents.get_last_run(events))

                elif command == 'microsoft-defender-cloud-apps-get-events':
                    command_results = CommandResults(
                        readable_output=tableToMarkdown('microsoft defender cloud apps events', events,
                                                        headerTransform=pascalToSpace),
                        outputs_prefix='Microsoft.Events',
                        outputs_key_field='_id',
                        outputs=events,
                        raw_response=events,
                    )
                    return_results(command_results)
                    if push_to_xsiam:
                        # publishing events to XSIAM
                        send_events_to_xsiam(events, vendor=vendor, product=product)

        # Log exceptions and return errors
        except Exception as e:
            demisto.error(traceback.format_exc())  # print the traceback
            return_error(f'Failed to execute {demisto.command()} command.\nError:\n{str(e)}')


    ''' ENTRY POINT '''

    if __name__ in ('__main__', '__builtin__', 'builtins'):
        # Args is always stronger. Get getIntegrationContext even stronger
        demisto_params = demisto.params() | demisto.args() | demisto.getLastRun()
        main(demisto.command(), demisto_params)

    register_module_line('Microsoft Defender for Cloud Apps Event Collector', 'end', __line__())
  type: python
  subtype: python3
  dockerimage: demisto/pydantic-jwt3:1.0.0.29883
fromversion: 6.8.0
marketplaces:
- marketplacev2
tests:
- No tests (auto formatted)
image: data:image/png;base64,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
